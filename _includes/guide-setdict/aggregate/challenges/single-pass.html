<p>
  It's possible to figure out which birds have been seen the least number of times
  using only a single pass through the data.
  The strategy is:
</p>
<ul>
  <li>
    Use a dictionary <code>counts_by_bird</code> to keep track of how many times each bird has been seen,
    and another <code>birds_by_count</code> to keep track of which birds have been seen how often.
    The first uses bird names as keys, and counts as values;
    the second uses counts as keys, and sets of bird names as values.
  </li>
  <li>
    When a bird is seen for the first time,
    it is added to the set stored with <code>birds_by_count[0]</code>,
    and <code>counts_by_bird[bird]</code> is set to 1.
  </li>
  <li>
    When a bird is seen for the second or subsequent time,
    <code>counts_by_bird[bird]</code> is incremented,
    and the bird is taken out of the set stored in <code>birds_by_count[old_count]</code>
    and added to the set stored in <code>birds_by_count[new_count]</code>.
  </li>
  <li>
    Once all the data has been read,
    the set associated with the smallest key in <code>birds_by_count</code> is returned.
  </li>
</ul>
<p>
  The diagram below shows the two data structures used by this algorithm
  and how they change when "loon" is read for the third time:
</p>
<figure id="f:single_pass_aggregation">
  <img src="setdict/single_pass_aggregation.png" alt="Single Pass Aggregation" />
  <figcaption>Single Pass Aggregation</figcaption>
</figure>
<p>
  Do you think this approach will actually run faster than the one used in the lesson?
  If so, why?
  If not, why not?
  And in either case,
  how much more complex do you think the code will be
  than the code given in the lesson?
  What measure of "complex" did you use, and why?
</p>
